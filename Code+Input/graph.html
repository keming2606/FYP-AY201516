<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node {
    stroke: #fff;
    stroke-width: 1.5px;
}
.link {
    stroke: #999;
    stroke-opacity: .6;
}
.d3-tip {
    line-height: 1;
    color: black;
}

</style>
<body>
	
	<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
	<script type='text/javascript' src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>
	<script type='text/javascript'>
	//Constants for the SVG
	var width = 1200,
		height = 1400;

	
	
	//Set up the force layout
	var force = d3.layout.force()
		.gravity(1)
		.charge(-150)
		.linkDistance(30)
		.size([width, height]);

	//Append a SVG to the body of the html page. Assign this SVG as an object to svg
	var svg = d3.select("body").append("svg")
		.attr("width", width)
		.attr("height", height);
		
	//Set up the colour scale
	var color = d3.scale.category20();
	


	//Set up tooltip
	var tip = d3.tip()
		.attr('class', 'd3-tip')
		.offset([-10, 0])
		.html(function (d) {
		return  d.name + "";
	})
	svg.call(tip); 
	
	d3.csv("graph.csv", function(error, links) {
	  if (error) throw error;
	  //console.log(links);
	  var nodesByName = {};
	  var groupByName = {};
	  var edgesNum = {};
	  var radius = 6;
	  // Create nodes for each unique source and target.
	  links.forEach(function(link) {
		link.source = nodeByName(link.tag);
		link.target = nodeByName(link.dest);
		groupByName[link.tag] = +link.relvalue;
		edgesNum[link.tag] = +link.edgestag;
		edgesNum[link.dest] = +link.edgesdest;
	  });

	  
		// Extract the array of nodes from the map by name.
	  var nodes = d3.values(nodesByName);

	  // Create the link lines.
	  var link = svg.selectAll(".link")
		  .data(links)
		.enter().append("line")
		.attr("class", "link")
    .style("marker-end",  "url(#suit)") // Modified line 
    ;
		//arrow	
		svg.append("defs").selectAll("marker")
		.data(["suit", "licensing", "resolved"])
	  .enter().append("marker")
		.attr("id", function(d) { return d; })
		.attr("viewBox", "0 -5 12 10")
		.attr("refX", 25)
		.attr("refY", 0)
		.attr("markerWidth", 6)
		.attr("markerHeight", 6)
		.attr("orient", "auto")
	  .append("path")
		.attr("d", "M0,-5L10,0L0,5 L10,0 L0, -5")
		.style("stroke", "#999")
		.style("opacity", "0.6");
		
	  // Create the groups under svg
		var gnodes = svg.selectAll('g.gnode')
		  .data(nodes)
		  .enter()
		  .append('g')
		  .classed('gnode', true);

		// Add one circle in each group  
		var node = gnodes.append("circle")
			.attr("class", "node")
			.attr("r", function (d) {return calRadius(edgesNum[d.name]); })
			.style("fill", function (d) {
			//console.log(groupByName[d.name])
			return color(groupByName[d.name]); })
			.call(force.drag)
			.on('mouseover', tip.show) 
			.on('mouseout', tip.hide);

		// Append the labels to each group
		var labels = gnodes.append("text")
		    .attr("dx", 12)
			.attr("dy", ".35em")
			.text(function(d) { 
				if (edgesNum[d.name] >10){
					return d.name;}
				else return ;			});
			
		var padding = 1, // separation between circles
		radius=8;
		var vis = d3.select("#chart")
	  .append("svg:svg")
		.attr("width", width)
		.attr("height", height)
		.attr("pointer-events", "all")
	  .append('svg:g')
		.call(d3.behavior.zoom().on("zoom", redraw))
	  .append('svg:g');

	vis.append('svg:rect')
		.attr('width', width)
		.attr('height', height)
		.attr('fill', 'white');
		
	  // Start the force layout.
	  force
		  .nodes(nodes)
		  .links(links)
		  .linkDistance(50)
		  .on("tick", tick)
		  .start();

	  function tick() {
		link.attr("x1", function(d) { return d.source.x; })
			.attr("y1", function(d) { return d.source.y; })
			.attr("x2", function(d) { return d.target.x; })
			.attr("y2", function(d) { return d.target.y; });
			
		
		//node.attr("cx", function(d) { return d.x; })
		//	.attr("cy", function(d) { return d.y; });
		gnodes.attr("transform", function(d) { return "translate(" + Math.max(radius, Math.min(width - radius, d.x)) + "," + Math.max(radius, Math.min(height - radius, d.y)) + ")"; });
		gnodes.each(collide(0.5));
		//gnodes.attr("transform", function(d) { 
		//	return 'translate(' + [d.x, d.y] + ')'; }); 
	  }

	  function nodeByName(name) {
		return nodesByName[name] || (nodesByName[name] = {name: name});
	  }
	  function redraw() {
	  console.log("here", d3.event.translate, d3.event.scale);
	  vis.attr("transform",
		  "translate(" + d3.event.translate + ")"
		  + " scale(" + d3.event.scale + ")");
	}
	  function calRadius(edge) {
		if(edge>10)
			return 6;
		else
			return 4;
	  }
	  function collide(alpha) {
		  var quadtree = d3.geom.quadtree(gnodes);
		  return function(d) {
			var rb = 2*radius + padding,
				nx1 = d.x - rb,
				nx2 = d.x + rb,
				ny1 = d.y - rb,
				ny2 = d.y + rb;
			quadtree.visit(function(quad, x1, y1, x2, y2) {
			  if (quad.point && (quad.point !== d)) {
				var x = d.x - quad.point.x,
					y = d.y - quad.point.y,
					l = Math.sqrt(x * x + y * y);
				  if (l < rb) {
				  l = (l - rb) / l * alpha;
				  d.x -= x *= l;
				  d.y -= y *= l;
				  quad.point.x += x;
				  quad.point.y += y;
				}
			  }
			  return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
			});
		  };
		}
	});
	

	</script>
</body>
</html>